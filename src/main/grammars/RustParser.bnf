{
    parserClass='org.rust.lang.core.parser.RustParser'
    parserUtilClass='org.rust.lang.core.parser.RustParserUtil'

    implements='org.rust.lang.core.psi.ext.RsCompositeElement'
    extends='org.rust.lang.core.psi.ext.RsCompositeElementImpl'

    elementTypeHolderClass='org.rust.lang.core.psi.RsElementTypes'

    elementTypeClass='org.rust.lang.core.psi.RsCompositeElementType'
    tokenTypeClass='org.rust.lang.core.psi.RsTokenType'

    psiClassPrefix='Rs'
    psiImplClassSuffix='Impl'
    psiPackage='org.rust.lang.core.psi'
    psiImplPackage='org.rust.lang.core.psi.impl'

    parserImports=[
      'static org.rust.lang.core.parser.RustParserUtil.PathParsingMode.*'
      'static org.rust.lang.core.parser.RustParserUtil.BinaryMode.*'
    ]

    tokens = [
        LBRACE      =  '{'
        RBRACE      =  '}'
        LBRACK      =  '['
        RBRACK      =  ']'
        LPAREN      =  '('
        RPAREN      =  ')'
        COLON       =  ':'
        COLONCOLON  =  '::'
        SEMICOLON   =  ';'
        COMMA       =  ','
        EQ          =  '='
        EXCLEQ      =  '!='
        EQEQ        =  '=='
        SHA         =  '#'
        EXCL        =  '!'
        PLUSEQ      =  '+='
        PLUS        =  '+'
        MINUSEQ     =  '-='
        MINUS       =  '-'
        OREQ        =  '|='
        ANDAND      =  '&&'
        ANDEQ       =  '&='
        AND         =  '&'
        OR          =  '|'
        LT          =  '<'
        XOREQ       =  '^='
        XOR         =  '^'
        MULEQ       =  '*='
        MUL         =  '*'
        DIVEQ       =  '/='
        DIV         =  '/'
        REMEQ       =  '%='
        REM         =  '%'
        GT          =  '>'
        DOT         =  '.'
        DOTDOT      =  '..'
        DOTDOTDOT   =  '...'
        FAT_ARROW   =  '=>'
        ARROW       =  '->'
        Q           =  '?'
        AT          =  '@'
        UNDERSCORE  =  '_'
        DOLLAR      =  '$'

        MACRO_KW  = 'macro'
        CSELF     = 'Self'
        TYPE_KW   = 'type'
        UNION     = 'union_kw'
        DEFAULT   = 'default_kw'

        SHEBANG_LINE = 'shebang_line'
        RESERVED_KEYWORD = 'reserved_keyword'
    ]

    elementType("(Fn|Anon|Lambda|Path)Parameter") = ValueParameter
    elementType("(Fn|Lambda|Path|FnType)Parameters") = ValueParameterList

    extends("(.+Expr|StructLiteral)") = Expr
    elementType(".+BinExpr") = BinaryExpr

    extends("Pat(Wild|Ref|Tup|Vec|Macro|Struct|Enum|Ident|Range|Uniq|QualPath)") = Pat

    elementType("ExprLikeMacro|ItemLikeMacro") = Macro
    extends("(Try|FormatLike|Assert|AssertEq)Macro") = Macro
    elementType(".+MacroInvocation|MacroRulesInvocation") = MacroInvocation

    generateTokenAccessors=true

    consumeTokenMethod("(.*_recover)|(.*Expr)|BinAssignOp") = "consumeTokenFast"
}

// This is the grammar of the Rust language which is used by Grammar Kit
// to generate the parser and the PSI classes. Rule `FooBar` corresponds
// to `RsFooBar` PSI class.
//
// Naming convention:
//
//   * tokens are lowercase: for, if, identifier
//   * rules are PascalCase: StructItem, EnumVariant
//   * macro rules are snake_cased: list_item
//   * recovery related rules are PascalCase_with_snake_suffix: Item_recover


File ::= [ SHEBANG_LINE ] InnerAttr* Items


///////////////////////////////////////////////////////////////////////////////////////////////////
// Attributes
///////////////////////////////////////////////////////////////////////////////////////////////////

fake Attr ::= MetaItem {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
}

InnerAttr ::= '#' '!' '[' MetaItem ']' {
  extends = Attr
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
OuterAttr ::= '#'     '[' MetaItem ']' {
  extends = Attr
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
private OuterAttr_first ::= '#'

MetaItem ::= identifier [ '=' LitExpr | MetaItemArgs ] {
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsMetaItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsMetaItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
MetaItemArgs ::= '(' [ <<comma_separated_list (MetaItem | LitExpr)>> ] ')' {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Paths
///////////////////////////////////////////////////////////////////////////////////////////////////

private PathIdent ::= !("union" identifier) identifier | self | super | 'Self'

fake Path ::= [ Path '::' ] PathIdent PathTypeArguments? {
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsPathImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsPathStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
private Path_first ::= identifier | self | 'Self' | super | '::' | '<'

private PathImpl ::= PathStart PathSegment*

PathStart ::= '::'?  PathIdent PathTypeArguments? { elementType = Path }
left PathSegment ::= '::' PathIdent PathTypeArguments? { elementType = Path }

private PathTypeArguments ::= <<isPathMode 'COLONS'>> ColonTypeArgumentList
                            | <<isPathMode 'NO_COLONS '>> ( TypeArgumentList | PathParameters RetType? ) // Fn(i32) -> i32 sugar

TypeArgumentList ::= TypeArgumentListImpl {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
ColonTypeArgumentList ::= '::' TypeArgumentListImpl { elementType = TypeArgumentList }

private TypeArgumentListImpl ::= '<' !'=' ( <<list_element Lifetime>>*
                                            <<list_element (!(identifier '=') TypeReference)>>*
                                            <<list_element AssocTypeBinding>>*) '>' { pin = 2 }
AssocTypeBinding ::= identifier '=' TypeReference


// Paths for expressions:
//     a::b::<T,U>::c
PathGenericArgsWithoutColons ::= <<pathMode 'NO_COLONS' PathImpl>> { elementType = Path }

// Paths without type arguments, for use declarations:
//     a::b::c
PathWithoutTypes ::= <<pathMode 'NO_TYPES' PathImpl>> { elementType = Path }

// Paths for types:
//    a::b<T,U>::c<V,W>
//    a::b<T,U>::c(V) -> W
//    a::b<T,U>::c(V)
PathGenericArgsWithColons ::= <<pathMode 'COLONS' PathImpl>> { elementType = Path }

// Qualified paths, formerly know as UFCS
//
//    <TYPE [as TRAIT_REF]> :: (path_without_types | path_generic_args_with_colons)
//    <T>::c<V,W>
//    <T as Foo>::c(V) -> W
fake QualifiedPath ::= '<' TypeReference [ as TraitRef] '>' '::' Path
QualifiedPathWithColons ::= '<' TypeReference [ as TraitRef] '>' '::' PathGenericArgsWithColons {
  elementType = QualifiedPath
}
QualifiedPathWithoutColons ::= '<' TypeReference [ as TraitRef] '>' '::' PathGenericArgsWithoutColons {
  elementType = QualifiedPath
}

// Path semantically constrained to resolve to a trait
TraitRef ::= PathGenericArgsWithoutColons {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Items
///////////////////////////////////////////////////////////////////////////////////////////////////

Vis ::= pub VisRestriction?
VisRestriction ::= '(' ( crate | ((&(self ')' | super ')') | in) PathWithoutTypes) ) ')'

//XXX: don't use contextual keywords in recover, because they remap tokens.
private default_ ::= <<defaultKeyword>>
private union ::= <<unionKeyword>>

private AttrsAndVis ::= OuterAttr* Vis?

private Item ::= Constant
               | TypeAlias
               | Function
               | TraitItem
               | ImplItem
               | ModItem
               | ModDeclItem
               | ForeignModItem
               | StructItem
               | EnumItem
               | UseItem
               | ExternCrateItem
               | MacroItem

private Item_with_recover ::= !('}' | <<eof>>) Item {
  pin = 1
  recoverWhile = Item_recover
}
private Item_first ::= '#' | pub | fn | const | extern | unsafe | struct | enum | use | identifier | mod | trait | static | TYPE_KW | impl | "union"
private Item_recover ::= !('}' | Item_first )

private Items ::= Item_with_recover*


///////////////////////////////////////////////////////////////////////////////////////////////////
// Lifetimes
///////////////////////////////////////////////////////////////////////////////////////////////////

LifetimeDecl ::= QUOTE_IDENTIFIER {
  implements = [ "org.rust.lang.core.psi.ext.RsNamedElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsLifetimeDeclImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsLifetimeDeclStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

Lifetime ::= QUOTE_IDENTIFIER {
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsLifetimeImplMixin"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////

// Parameters
fake ValueParameter ::= Pat? TypeReference? {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

FnParameter ::= [ Pat ':' ] TypeReference
LambdaParameter ::= Pat TypeAscription?
AnonParameter ::= [ RestrictedPat ':' ] TypeReference
PathParameter ::= TypeReference !'='

SelfParameter ::= [ '&' Lifetime? ] mut? self TypeAscription? {
  implements = [ "org.rust.lang.core.psi.ext.RsNamedElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsSelfParameterImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsSelfParameterStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

fake ValueParameterList ::= SelfParameter? ValueParameter* '...'? {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

FnParameters          ::= '(' !',' [ SelfParameter (',' | &')') ]
                                   [ FnParameter (',' FnParameter)* [ ',' '...'? ] ','? ]
                          ')' { pin = 1 }
LambdaParameters      ::= '|' !',' [ <<comma_separated_list LambdaParameter>> ] '|'

FnTypeParameters      ::= <<variadic_params_impl AnonParameter>>
PathParameters        ::= '(' [ <<comma_separated_list PathParameter>> ] ')' { pin = 1 }


private meta variadic_params_impl ::= '(' [ <<param>> (',' <<param>>)*  [ ',' '...'? ] ] ')' { pin = 1 }

private RestrictedPat ::= &( [ mut | '&' '&'? ] ( identifier | '_' ) ) Pat

TypeParameterList ::= '<' LifetimesParams TypeParams '>' {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private LifetimesParams ::= <<list_element LifetimeParameter>>*
private TypeParams      ::= <<list_element TypeParameter>>*

LifetimeParameter ::= OuterAttr* LifetimeDecl LifetimeParamBounds? {
  implements = [ "org.rust.lang.core.psi.ext.RsNamedElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsLifetimeParameterImplMixin"
}

LifetimeParamBounds ::= ':' Lifetime ('+' Lifetime)*

TypeParameter ::= OuterAttr* identifier TypeParamBounds? [ '=' TypeReference ] {
  implements = [ "org.rust.lang.core.psi.ext.RsNamedElement" ]
  extends = "org.rust.lang.core.psi.ext.RsStubbedNamedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsTypeParameterStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

TypeParamBounds ::= ':' [ Polybound ('+' Polybound)* '+'? ] {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

Polybound ::= [ ForLifetimes | '?' ] Bound {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

WhereClause ::= where <<comma_separated_list WherePred>> {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

WherePred ::= Lifetime LifetimeParamBounds | ForLifetimes? TypeReference TypeParamBounds {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ForLifetimes ::= for '<' LifetimesParams '>'

ExternAbi ::= extern STRING_LITERAL?

RetType ::= '->' TypeReference {
  pin = 1
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

Function ::= OuterAttr*
             default_?
             Vis?
             const? unsafe? ExternAbi?
             fn identifier
             TypeParameterList?
             FnParameters
             RetType?
             WhereClause?
             (';' | InnerAttrsAndBlock)
{
  pin = 'identifier'
  implements = [ "org.rust.lang.core.psi.ext.RsQualifiedNamedElement"
                 "org.rust.lang.core.psi.ext.RsGenericDeclaration"
                 "org.rust.lang.core.psi.ext.RsOuterAttributeOwner"
                 "org.rust.lang.core.psi.ext.RsInnerAttributeOwner"
                 "org.rust.lang.core.psi.ext.RsTypeBearingItemElement"
                 "org.rust.lang.core.psi.ext.RsAbstractable" ]
  mixin = "org.rust.lang.core.psi.ext.RsFunctionImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsFunctionStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
}

Pat ::= PatWild
      | PatRef
      | PatTup
      | PatVec
      | PatMacro
      | PatStruct
      | PatEnum
      | PatIdent
      | PatRange
      | PatUniq
      | PatQualPath

private Pat_first ::= '_' | '&' | '(' | '[' | Path_first | LitExpr  | box | '-' | ref | mut


PatQualPath ::= QualifiedPathWithColons
PatUniq ::= box Pat

// XXX(matklad): it is impossible to distinguish between nullary enum variants
// and identifiers during parsing.
//
//   match x {
//       None => { } // match enum variant
//       Name => { } // bind Name to x
//   }
PatIdent ::= PatBinding [ '@' Pat ]

PatStruct ::= PathGenericArgsWithColons '{' PatField_with_recover* '..'? '}'
PatEnum   ::= PathGenericArgsWithColons '(' SeqPat ')'

// TODO: actual recover
private Pat_with_recover ::= Pat (',' | &(')' | ']' | '..'))
private PatField_with_recover ::= PatField (',' | & '}')

PatRange ::= LitOrPath [ '...' LitOrPath ]
private LitOrPath ::= LitExpr | PathExpr | &('-' LitExpr) UnaryExpr

PatTup ::= '(' SeqPat ')'
PatVec ::= '[' SeqPat ']'
// NB: there are `[x, .. , y]` and `[x, z.. , y]`
private SeqPat ::= Pat_with_recover* ['..' [',' Pat_with_recover+] ]

PatRef ::= '&' mut? Pat

PatWild ::= '_'
PatBinding ::= BindingMode? identifier !'...' !'::' {
  implements = [ "org.rust.lang.core.psi.ext.RsNamedElement"
                 "org.rust.lang.core.psi.ext.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsPatBindingImplMixin"
}

PatField ::= identifier ':' Pat | box? PatBinding

BindingMode ::= ref mut? | mut

Constant ::= OuterAttr* default_? Vis? (static mut? | const) identifier TypeAscription [ '=' AnyExpr ] ';' {
  pin = 'identifier'
  implements = [ "org.rust.lang.core.psi.ext.RsNamedElement"
                 "org.rust.lang.core.psi.ext.RsItemElement"
                 "org.rust.lang.core.psi.ext.RsAbstractable" ]
  mixin = "org.rust.lang.core.psi.ext.RsConstantImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsConstantStub"
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

UseItem ::= AttrsAndVis use UsePath ';' {
  pin = "use"
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.ext.RsItemElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsUseItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsUseItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

// You can see the following after the `use`:
//  ::{};
//  {foo, bar};
//  foo::bar as baz;
//  foo::bar::{self, foo};
//  foo::{};
//  ::foo::*;
private UsePath ::= '::'? UseProjection
                  | PathWithoutTypes [ Alias | '::' UseProjection ]

private UseProjection ::= UseGlobList | '*'

UseGlobList ::= '{' UseGlob_with_recover* '}' {
  pin = 1
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

UseGlob ::= (identifier | self) Alias? {
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsUseGlobImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsUseGlobStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private UseGlob_with_recover ::= !'}' UseGlob (',' | &'}') {
  pin = 1
  recoverWhile = UseGlob_recover
}
private UseGlob_recover ::= !('}' | self | identifier)

Alias ::= as identifier {
  implements = [ "org.rust.lang.core.psi.ext.RsNamedElement" ]
  extends = "org.rust.lang.core.psi.ext.RsStubbedNamedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsAliasStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ExternCrateItem ::= AttrsAndVis extern crate identifier Alias? ';' {
  pin = "identifier"
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement"
                 "org.rust.lang.core.psi.ext.RsNamedElement"
                 "org.rust.lang.core.psi.ext.RsItemElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsExternCrateItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsExternCrateItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ModItem ::= AttrsAndVis mod identifier '{' InnerAttr* Items '}' {
  pin = 4
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.ext.RsNamedElement"
                 "org.rust.lang.core.psi.ext.RsItemElement"
                 "org.rust.lang.core.psi.ext.RsMod"
                 "org.rust.lang.core.psi.ext.RsInnerAttributeOwner" ]
  mixin = "org.rust.lang.core.psi.ext.RsModItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsModItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ModDeclItem ::= AttrsAndVis mod identifier ';' {
  pin = 'identifier' // make sure `ModDeclItem` goes **after** `ModItem`
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement"
                 "org.rust.lang.core.psi.ext.RsNamedElement"
                 "org.rust.lang.core.psi.ext.RsItemElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsModDeclItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsModDeclItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ForeignModItem ::= AttrsAndVis ExternAbi '{' InnerAttr* ForeignDecl* '}' {
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.ext.RsItemElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsForeignModItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private ForeignDecl ::= Constant | Function


///////////////////////////////////////////////////////////////////////////////////////////////////
// Struct & Enums
///////////////////////////////////////////////////////////////////////////////////////////////////

StructItem ::= AttrsAndVis (struct | union) identifier TypeParameterList?
               ( TupleStructTail | BlockStructTail | UnitStructTail ) {
  pin = 2
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.ext.RsStructOrEnumItemElement"
                 "org.rust.lang.core.psi.ext.RsFieldsOwner" ]
  mixin = "org.rust.lang.core.psi.ext.RsStructItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsStructItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private TupleStructTail ::= TupleFields WhereClause? ';' { pin = 1 }
private UnitStructTail ::= WhereClause? ';'
private BlockStructTail ::= WhereClause? BlockFields

EnumItem ::= AttrsAndVis enum identifier TypeParameterList? WhereClause? EnumBody {
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = "org.rust.lang.core.psi.ext.RsStructOrEnumItemElement"
  mixin = "org.rust.lang.core.psi.ext.RsEnumItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsEnumItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

EnumBody ::= '{' [ <<comma_separated_list EnumVariant>> ] '}' {
  pin = 1
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

EnumVariant ::= OuterAttr* identifier VariantArgs? {
  pin = 2
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.ext.RsQualifiedNamedElement"
                 "org.rust.lang.core.psi.ext.RsNamedElement"
                 "org.rust.lang.core.psi.ext.RsOuterAttributeOwner"
                 "org.rust.lang.core.psi.ext.RsFieldsOwner" ]
  mixin = "org.rust.lang.core.psi.ext.RsEnumVariantImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsEnumVariantStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private VariantArgs ::= BlockFields | TupleFields | VariantDiscriminant

BlockFields ::= '{' (FieldDecl (',' | &'}'))* '}' {
  pin = 1
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

TupleFields ::= '(' (TupleFieldDecl (',' | &')'))* ')' {
  pin = 1
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

VariantDiscriminant ::= '=' AnyExpr { pin = 1 }

FieldDecl ::= AttrsAndVis identifier TypeAscription {
  pin = 2
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.ext.RsOuterAttributeOwner"
                 "org.rust.lang.core.psi.ext.RsVisibilityOwner"
                 "org.rust.lang.core.psi.ext.RsNamedElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsFieldDeclImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsFieldDeclStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
  recoverWhile = Field_recover
}
private Field_recover ::= !('}' | ',')

TupleFieldDecl ::= AttrsAndVis TypeReference {
  implements = [ "org.rust.lang.core.psi.ext.RsOuterAttributeOwner"
                 "org.rust.lang.core.psi.ext.RsVisibilityOwner" ]
  mixin = "org.rust.lang.core.psi.ext.RsTupleFieldDeclImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  recoverWhile = TupleField_recover
}
private TupleField_recover ::= !(')' | ',')


///////////////////////////////////////////////////////////////////////////////////////////////////
// Trait & Impl
///////////////////////////////////////////////////////////////////////////////////////////////////

TraitItem ::= AttrsAndVis unsafe? trait identifier TypeParameterList? TypeParamBounds? WhereClause? TraitOrImplBody {
  pin = "trait"
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.ext.RsTraitOrImpl"
                 "org.rust.lang.core.psi.ext.RsQualifiedNamedElement"
                 "org.rust.lang.core.psi.ext.RsTypeBearingItemElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsTraitItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsTraitItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ImplItem ::= AttrsAndVis unsafe? impl TypeParameterList? ( TraitImpl | InherentImpl ) {
  pin = "impl"
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.ext.RsTraitOrImpl" ]
  mixin = "org.rust.lang.core.psi.ext.RsImplItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsImplItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
private InherentImpl ::= TypeReference !for WhereClause? TraitOrImplBody { pin = 2 }
private TraitImpl ::= '!'? TraitRef for (AutoTraitImpl | TypeTraitImpl) { pin = 3 }
private AutoTraitImpl ::= '..' '{' '}' { pin = 1 }
private TypeTraitImpl ::= TypeReference WhereClause? TraitOrImplBody { pin = 1 }

private TraitOrImplBody ::= '{' InnerAttr* Member* '}' { pin = 1 }

private Member ::= !'}' ( Function | Constant | TypeAlias | ImplMacroMember ) {
  pin = 1
  recoverWhile = Member_recover
}
private Member_recover ::=  !('#' | Vis | extern | const | static | unsafe | fn | (identifier '!') | TYPE_KW | "default" | '}')

///////////////////////////////////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////////////////////////////////

private TypeAscription ::= ':' TypeReference

private TypeReferenceInner ::= ( ArrayType
                               | RefLikeType
                               | FnPointerType
                               | BaseType
                               // External rule to find the difference between `(T)` and `(T,)`
                               | <<tupleOrParenType TypeReferenceInner TupleType_upper>>
                               | ForInType
                               | ImplTraitType) ('+' Bound)*

private ScalarTypeReferenceInner ::= ArrayType
                                   | RefLikeType
                                   | FnPointerType
                                   | BaseType
                                   | <<tupleOrParenType ScalarTypeReferenceInner TupleType_upper>>
                                   | ForInType
                                   | ImplTraitType

TypeReference ::= TypeReferenceInner {
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ScalarTypeReference ::= ScalarTypeReferenceInner { elementType = TypeReference }

ArrayType ::= '[' TypeReference [';' AnyExpr] ']' {
  implements = "org.rust.lang.core.psi.ext.RsTypeElement"
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsArrayTypeStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

RefLikeType ::= ( '&' Lifetime? mut? | '*' [ const | mut ] ) TypeReference {
  implements = "org.rust.lang.core.psi.ext.RsTypeElement"
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsRefLikeTypeStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

FnPointerType ::= [ unsafe? ExternAbi? ] fn FnTypeParameters RetType? {
  implements = "org.rust.lang.core.psi.ext.RsTypeElement"
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

TupleType ::= '(' [ <<comma_separated_list TypeReference>> ] ')' {
  implements = "org.rust.lang.core.psi.ext.RsTypeElement"
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private TupleType_upper ::= (',' TypeReference)* ','? ')' {
  stubClass = "org.rust.lang.core.stubs.RsTypeElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

Bound ::= Lifetime | TraitRef {
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ForInType ::= ForLifetimes (FnPointerType | TraitRef) {
  implements = "org.rust.lang.core.psi.ext.RsTypeElement"
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ImplTraitType ::= impl Polybound ('+' Polybound)* {
  implements = "org.rust.lang.core.psi.ext.RsTypeElement"
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

BaseType ::= '(' ')' | '_' | '!' | !'<' PathGenericArgsWithoutColons | &'<' TypeQualPath {
  implements = "org.rust.lang.core.psi.ext.RsTypeElement"
  extends = "org.rust.lang.core.psi.ext.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsBaseTypeStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

TypeAlias ::= OuterAttr* default_? Vis? TYPE_KW identifier
              [ TypeParameterList WhereClause? | WhereClause | TypeParamBounds ]
              [ '=' TypeReference ] ';' {
  pin = 'identifier'
  implements = [ "org.rust.lang.core.psi.ext.RsQualifiedNamedElement"
                 "org.rust.lang.core.psi.ext.RsTypeBearingItemElement"
                 "org.rust.lang.core.psi.ext.RsGenericDeclaration"
                 "org.rust.lang.core.psi.ext.RsAbstractable" ]
  mixin = "org.rust.lang.core.psi.ext.RsTypeAliasImplMixin"
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  stubClass = "org.rust.lang.core.stubs.RsTypeAliasStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

TypeQualPath ::= QualifiedPathWithoutColons

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////

// https://doc.rust-lang.org/reference.html#operator-precedence
// https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities
//
// Rust expression grammar allows or forbids struct literals depending on context.
// There are `no_struct_lit_expr` and `any_expr` productions for this two cases.
// `expr` production is an implementation detail. It passes the context information to the child expressions.
Expr ::= RetExpr
       | LambdaExpr
       | AssignBinExpr

       | WhileExpr
       | IfExpr
       | ForExpr
       | LoopExpr
       | MatchExpr
       | BlockExpr

       | ContExpr
       | BreakExpr
       | FullRangeExpr
       | OpenRangeExpr
       | BoolOrBinExpr
       | BoolAndBinExpr
       | CompBinExpr
       | RelCompBinExpr
       | BitOrBinExpr
       | BitXorBinExpr
       | BitAndBinExpr
       | BitShiftBinExpr
       | AddBinExpr
       | MulBinExpr
       | CastExpr
       | UnaryExpr
       | TryExpr
       | AtomExpr

Expr_first ::= return | '|' | Path_first | '{' | '[' | '(' | '..' | '...' | true | false | box | QUOTE_IDENTIFIER
  | '-' | '*' | '!' | '&' | move | LitExpr | while | if | for | continue | break  | loop | match | unsafe

// https://github.com/rust-lang/rfcs/blob/master/text/0092-struct-grammar.md
NoStructLitExpr ::= <<structLiterals 'OFF' <<stmtMode 'OFF' Expr>> >> { elementType = Expr }
AnyExpr ::= <<structLiterals 'ON' <<stmtMode 'OFF' Expr>> >> { elementType = Expr }
StmtModeExpr ::= <<structLiterals 'ON' <<stmtMode 'ON' Expr>> >> { elementType = Expr }
StmtModeExprOff ::= <<stmtMode 'OFF' Expr>> { elementType = Expr }

BlockExpr ::= [ unsafe &'{' ] SimpleBlock


private AtomExpr ::= LitExpr
                    | MacroExpr
                    | StructLiteral
                    | QualPathExpr
                    | MethodCallExpr
                    | FieldExpr
                    | IndexExpr
                    | PathExpr !'('
                    | CallExpr
                    | ArrayExpr
                    | UnitExpr
                    | TupleOrParenExpr

fake BinaryExpr ::= Expr+ {
  methods=[
    left="/Expr[0]"
    right="/Expr[1]"
  ]
}

AssignBinExpr ::= Expr BinAssignOp Expr    { rightAssociative = true }
private BinAssignOp ::= gtgteq | ltlteq | '|=' | '^=' | '&=' | '=' | '+=' | '-=' | '*=' | '/=' | '%='

CompBinExpr      ::= Expr !<<isCompleteBlockExpr>> ('==' | '!=') StmtModeExprOff
RelCompBinExpr   ::= Expr !<<isCompleteBlockExpr>> ('<' !('<' | '=') | '>' !('>' | '=') | lteq | gteq) StmtModeExprOff
BitShiftBinExpr  ::= Expr !<<isCompleteBlockExpr>> (ltlt | gtgt) StmtModeExprOff
AddBinExpr       ::= Expr !<<isCompleteBlockExpr>> ('+' | '-') StmtModeExprOff
MulBinExpr       ::= Expr !<<isCompleteBlockExpr>> ('*' | '/' | '%') StmtModeExprOff

// <expr> | <expr> has higher priority than <expr> || <expr>
BoolOrBinExpr    ::= Expr !<<isCompleteBlockExpr>> oror StmtModeExprOff
BoolAndBinExpr   ::= Expr !<<isCompleteBlockExpr>> andand StmtModeExprOff
BitOrBinExpr     ::= Expr !(<<isCompleteBlockExpr>> | oror)   '|' StmtModeExprOff
BitAndBinExpr    ::= Expr !(<<isCompleteBlockExpr>> | andand) '&' StmtModeExprOff
BitXorBinExpr    ::= Expr !<<isCompleteBlockExpr>> '^' StmtModeExprOff

CastExpr ::= Expr (as | ':')  ScalarTypeReference

TryExpr ::= Expr '?'

UnaryExpr ::= (box | '-' | '*' | '!' | '&' mut?) Expr

LambdaExpr ::= move? LambdaParameters RetType? AnyExpr

StructLiteral ::= <<checkStructAllowed>> PathGenericArgsWithColons StructLiteralBody

StructLiteralBody ::= '{' StructLiteralField_with_recover* ('..'  AnyExpr)? '}' { pin = 1 }

StructLiteralField ::= OuterAttr* identifier [ ':' AnyExpr ] {
  pin = 2
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsStructLiteralFieldImplMixin"
}

private StructLiteralField_with_recover ::= StructLiteralField (',' | &'}') {
  pin = 1
  recoverWhile = StructLiteralField_recover
}

private StructLiteralField_recover ::= !(identifier | ',' | '}' | '..' | '#')

PathExpr ::= PathGenericArgsWithColons

QualPathExpr ::= QualifiedPathWithColons

WhileExpr ::= LabelDecl? while Condition SimpleBlock {
  pin = 'while'
  implements = [ "org.rust.lang.core.psi.ext.RsLabeledExpression" ]
}
Condition ::= [ let Pat '=' ] NoStructLitExpr

LoopExpr ::= LabelDecl? loop SimpleBlock {
  pin = 'loop'
  implements = [ "org.rust.lang.core.psi.ext.RsLabeledExpression" ]
}

ContExpr ::= continue Label?

BreakExpr ::= break Label? AnyExpr?

ForExpr ::= LabelDecl? for Pat in NoStructLitExpr SimpleBlock {
  pin = 'for'
  implements = [ "org.rust.lang.core.psi.ext.RsLabeledExpression" ]
}

LabelDecl ::= QUOTE_IDENTIFIER ':' {
  implements = [ "org.rust.lang.core.psi.ext.RsNamedElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsLabelDeclImplMixin"
}
Label ::= QUOTE_IDENTIFIER {
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsLabelImplMixin"
}

MatchExpr ::= match NoStructLitExpr MatchBody { pin = 'match'}
MatchBody ::= '{' MatchArm* '}' { pin = 1 }
MatchArm ::= OuterAttr* Pat ('|' Pat)* MatchArmGuard? '=>' StmtModeExpr (',' | (&'}' | <<isBlock>>)) {
  pin = 2
  recoverWhile = MatchArm_recover
}
private MatchArm_recover ::= !(Pat_first | OuterAttr_first | '}')
MatchArmGuard ::= if AnyExpr

IfExpr ::= if Condition SimpleBlock ElseBranch? { pin = 'if' }
ElseBranch ::= else ( IfExpr | SimpleBlock )

RetExpr ::= return Expr?

UnitExpr ::= '(' ')'

fake TupleExpr ::= '(' AnyExpr+ ')'
fake ParenExpr ::= '(' AnyExpr ')'

// XXX: without the `pin`, upper rules won't work, GK can change element type
// of the frame only if it already has some type
// https://github.com/JetBrains/Grammar-Kit/blob/d716ade658c1f8e1f84bd0d61764c9949a7df5f2/src/org/intellij/grammar/parser/GeneratedParserUtilBase.java#L656
TupleOrParenExpr ::= '(' AnyExpr (TupleExprUpper | ParenExprUpper) { pin = 1 }
upper TupleExprUpper ::= ',' [ AnyExpr (',' AnyExpr)* ','? ] ')' { elementType = TupleExpr}
upper ParenExprUpper ::= ')' { elementType = ParenExpr }

ArrayExpr ::= '[' ArrayInitializer ']' { pin = 1 }
private ArrayInitializer ::= [ AnyExpr ( ';' AnyExpr | (',' AnyExpr)* ','? ) ]

fake RangeExpr ::= Expr? ('..' | '...') Expr?

FullRangeExpr ::= Expr ( '..' (<<checkBraceAllowed>> Expr)? | '...' (<<checkBraceAllowed>> Expr) ) { elementType = RangeExpr }
OpenRangeExpr ::=      ( '..' (<<checkBraceAllowed>> Expr)? | '...' (<<checkBraceAllowed>> Expr) ) { elementType = RangeExpr }

IndexExpr ::= Expr IndexArg
// Do not inline this rule, it breaks expression parsing
private IndexArg ::= '[' Expr ']'

CallExpr ::= Expr !<<isCompleteBlockExpr>> ValueArgumentList

MethodCallExpr ::= Expr '.' identifier ColonTypeArgumentList? ValueArgumentList {
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsMethodCallExprImplMixin"
}

ValueArgumentList ::= '(' <<comma_separated_list AnyExpr>>? ')' { pin = 1 }

FieldId ::= identifier | INTEGER_LITERAL

FieldExpr ::= Expr '.' FieldId {
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsFieldExprImplMixin"
}

LitExpr ::= STRING_LITERAL | BYTE_STRING_LITERAL
          | RAW_STRING_LITERAL | RAW_BYTE_STRING_LITERAL
          | CHAR_LITERAL | BYTE_LITERAL
          | INTEGER_LITERAL | FLOAT_LITERAL
          | BOOL_LITERAL

///////////////////////////////////////////////////////////////////////////////////////////////////
// Macros
///////////////////////////////////////////////////////////////////////////////////////////////////

fake Macro ::= MacroInvocation MacroArg?

// Various kinds of macros
ExprLikeMacro ::= MacroInvocation MacroArg
ItemLikeMacro ::= MacroInvocation ItemMacroArg

TryMacro ::= TryMacroInvocation TryMacroArgs { pin = 1 }
FormatLikeMacro ::= FormatLikeMacroInvocation FormatMacroArgs { pin = 1 }
AssertMacro ::= AssertMacroInvocation AssertMacroArgs { pin = 1 }
AssertEqMacro ::= AssertEqMacroInvocation AssertEqMacroArgs { pin = 1 }

VecMacro ::= VecMacroInvocation VecMacroArgs { pin = 1 }
LogMacro ::= LogMacroInvocation LogMacroArgs { pin = 1 }

MacroDefinition ::= MacroRulesInvocation identifier MacroDefinitionPatternList {
  pin = 1
  extends = ItemLikeMacro
}

MacroDefinitionPatternList ::= <<macro_definition_delim (MacroDefinitionPattern ';'?)* >>

private meta macro_definition_delim ::= '(' <<param>> ')' ';'
                                      | '{' <<param>> '}'
                                      | '[' <<param>> ']' ';' { pin = 1 }
MacroDefinitionPattern ::= MacroPattern '=>' MacroBody
MacroBinding ::= <<macroIdentifier>>

MacroPattern ::= '(' MacroMatchingTree* ')'
               | '{' MacroMatchingTree* '}'
               | '[' MacroMatchingTree* ']'
MacroMatchingTree ::=  '(' MacroMatchingTree* ')'
                     | '{' MacroMatchingTree* '}'
                     | '[' MacroMatchingTree* ']'
                     | (MacroPatternSimpleMatching | MacroPatternComplexMatching)+
                     | << placeholderMacroToken >>+

MacroPatternComplexMatching ::= '$' '(' MacroMatchingTree* ')' <<tokenAfterComplexPattern>>* ('*' | '+')
MacroPatternSimpleMatching ::= '$' MacroBinding ':' identifier {
  implements = [ "org.rust.lang.core.psi.ext.RsNamedElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsMacroPatternSimpleMatchingImplMixin"
}

MacroBody ::= '(' MacroTokenTree* ')'
            | '{' MacroTokenTree* '}'
            | '[' MacroTokenTree* ']'
MacroTokenTree ::= '(' MacroTokenTree* ')'
                 | '{' MacroTokenTree* '}'
                 | '[' MacroTokenTree* ']'
                 | (MacroBodyComplexMatching | MacroBodySimpleMatching) +
                 | << placeholderMacroToken >> +
MacroBodyComplexMatching ::= '$' '(' MacroTokenTree* ')' <<tokenAfterComplexPattern>>* ('*' | '+')
MacroBodySimpleMatching ::= '$' (MacroBinding | "crate") {
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsMacroBodySimpleMatchingImplMixin"
}

private BuildInMacro ::= TryMacro
                       | FormatLikeMacro
                       | AssertMacro
                       | AssertEqMacro
                       | VecMacro
                       | LogMacro

private ZzMacroCall ::= BuildInMacro | ExprLikeMacro { pin(".*") = MacroInvocation }
private ZzMacroItem ::= MacroDefinition | ItemLikeMacro {
  pin(".*") = MacroInvocation
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
}

// Invocations
MacroInvocation ::= identifier '!' identifier? {
  implements = [ "org.rust.lang.core.psi.ext.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.ext.RsMacroInvocationImplMixin"
}

TryMacroInvocation ::= "try" '!'
VecMacroInvocation ::= "vec" '!'
LogMacroInvocation ::= ( "trace" | "log" | "warn" | "debug" | "error" | "info" ) '!'
MacroRulesInvocation ::= "macro_rules" '!'

// https://doc.rust-lang.org/std/fmt/
FormatLikeMacroInvocation ::= ( "format"
                              | "format_args"
                              | "write"
                              | "writeln"
                              | "print"
                              | "println"
                              | "panic") '!'

AssertMacroInvocation ::= ( "assert" | "debug_assert" ) '!'

AssertEqMacroInvocation ::= ( "assert_eq"
                            | "assert_ne"
                            | "debug_assert_eq"
                            | "debug_assert_ne") '!'

// Arguments
MacroArg ::= <<macro_args_delim TokenTrees>>

ItemMacroArg ::= '(' TokenTrees ')' ';'
               | '{' TokenTrees '}'
               | '[' TokenTrees ']' ';' {
  pin = 1
  elementType = MacroArg
}

TryMacroArgs ::= <<macro_args_delim AnyExpr>>
VecMacroArgs ::= '[' ArrayInitializer ']' | '(' ArrayInitializer ')' | '{' ArrayInitializer '}' {
  pin = 1
}

private ZzLogMacroArgs ::= ('target' ':' Expr ','?)? (<<comma_separated_list FormatMacroArg>>)?
LogMacroArgs ::=  <<macro_args_delim ZzLogMacroArgs>>

private ZzAssertMacroArgs ::= AnyExpr [ ',' <<comma_separated_list FormatMacroArg>> ]
AssertMacroArgs ::= <<macro_args_delim ZzAssertMacroArgs>>

private ZzAssertEqMacroArgs ::= AnyExpr ',' AnyExpr [ ',' <<comma_separated_list FormatMacroArg>> ]
AssertEqMacroArgs ::= <<macro_args_delim ZzAssertEqMacroArgs>>

FormatMacroArgs ::= <<macro_args_delim [ <<comma_separated_list FormatMacroArg>> ] >>
FormatMacroArg ::= [ identifier '=' ] AnyExpr

private meta macro_args_delim ::= '(' <<param>> ')'
                                | '{' <<param>> '}'
                                | '[' <<param>> ']' { pin = 1 }

// Macro wrappers
MacroExpr ::= ZzMacroCall
PatMacro  ::= ZzMacroCall
// TODO: Maybe implement item-related stuff for this production?
MacroItem ::= AttrsAndVis ZzMacroItem {
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.ext.RsOuterAttributeOwner"; "org.rust.lang.core.psi.ext.RsNamedElement" ]
  stubClass = "org.rust.lang.core.stubs.RsMacroItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
  mixin = "org.rust.lang.core.psi.ext.RsMacroItemImplMixin"
}
ImplMacroMember ::= ZzMacroItem

private TokenTrees ::= TokenTree*

TokenTree ::= '(' TokenTrees ')'
            | '{' TokenTrees '}'
            | '[' TokenTrees ']'
            | << unpairedToken >> +


///////////////////////////////////////////////////////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////////////////////////////////////////////////////

fake Block ::= '{' InnerAttr* (Item | Stmt)* Expr? '}' {
  pin = 1
  implements = "org.rust.lang.core.psi.ext.RsItemsOwner"
}

SimpleBlock ::= '{' BlockElement* '}' {
  pin = 1
  elementType = Block
}

InnerAttrsAndBlock ::= '{' InnerAttr* BlockElement* '}' {
  pin = 1
  elementType = Block
}
private BlockElement ::= !'}' (ExprStmtOrLastExpr | Stmt | Item) {
  pin = 1
  recoverWhile = BlockElement_recover
}
private BlockElement_recover ::= !('}' | Item_first | Expr_first | let | ';')

Stmt ::= LetDecl | EmptyStmt | never ';'

ExprStmtOrLastExpr ::= OuterAttr? StmtModeExpr (ExprStmtUpper | LastExprUpper)

upper ExprStmtUpper ::= ';' | () <<isBlock>> !('}') { elementType = ExprStmt }
upper LastExprUpper ::= () &'}' { elementType = Expr pin = 1 }

fake ExprStmt ::= OuterAttr? AnyExpr ';'? { extends = Stmt }

LetDecl ::= OuterAttr? let Pat TypeAscription? [ '=' AnyExpr ] ';' {
  extends = Stmt
  pin = "let"
}

EmptyStmt ::= ';' { extends = Stmt }


///////////////////////////////////////////////////////////////////////////////////////////////////
// Utils
///////////////////////////////////////////////////////////////////////////////////////////////////

private gtgteq ::= <<gtgteqImpl>>  | never GTGTEQ { name = ">>=" }
private gtgt   ::= <<gtgtImpl>>    | never GTGT   { name = ">>" }
private gteq   ::= <<gteqImpl>>    | never GTEQ   { name = ">=" }
private ltlteq ::= <<ltlteqImpl>>  | never LTLTEQ { name = "<<=" }
private ltlt   ::= <<ltltImpl>>    | never LTLT   { name = "<<" }
private lteq   ::= <<lteqImpl>>    | never LTEQ   { name = "<=" }
private oror   ::= <<ororImpl>>    | never OROR   { name = "||" }
private andand ::= <<andandImpl>>  | never ANDAND { name = "&&" }

private never ::= !()

// Trailing commas are allowed
private meta comma_separated_list ::= <<param>> ( ',' <<param>> )* ','?
private meta list_element ::= <<param>> (',' | &'>') { pin = 1 }
